// Transcription Models
// Real-time transcription and speaker diarization

enum TranscriptStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

model Transcript {
  id String @id @default(cuid())

  meetingId String  @unique
  meeting   Meeting @relation(fields: [meetingId], references: [id], onDelete: Cascade)

  // Full transcript text (compiled from segments)
  fullText String? @db.Text

  // Structured segments with speaker info
  segments TranscriptSegment[]

  // Processing status: PENDING → ACTIVE → COMPLETED | FAILED
  status TranscriptStatus @default(PENDING)

  // Metadata
  language  String @default("en-US")
  wordCount Int?

  // Lifecycle timestamps
  startedAt DateTime?
  endedAt   DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model TranscriptSegment {
  id String @id @default(cuid())

  transcriptId String
  transcript   Transcript @relation(fields: [transcriptId], references: [id], onDelete: Cascade)

  // Jitsi message ID for idempotency (unique per transcript)
  messageId String

  // Speaker info
  speakerId          Int      // Numeric speaker ID from diarization
  jitsiParticipantId String?  // Jitsi participant ID
  speakerName        String?  // Snapshot at time of speech
  speakerUserId      String?  // Better Auth userId (nullable for guests)

  // Timing (seconds from meeting start, may be null if unavailable)
  startTime  Float?
  endTime    Float?
  receivedAt DateTime @default(now()) // For ordering fallback

  // Content
  text       String  @db.Text
  confidence Float?  // Transcription confidence score (0-1)
  isFinal    Boolean @default(false) // final vs stable/provisional

  // Word-level timing (optional, for precise highlighting)
  words Json? // Array of {word, start, end, confidence}

  createdAt DateTime @default(now())

  @@unique([transcriptId, messageId]) // Idempotency constraint
  @@index([transcriptId, receivedAt])
  @@index([speakerId])
}
