// Meeta - Self-Hosted Video Conferencing with AI Transcription
// Database Schema

generator client {
  provider = "prisma-client-js"
  output   = "../src/app/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

// ============================================
// Better Auth Models
// ============================================

model user {
  id            String  @id
  name          String
  email         String  @unique
  emailVerified Boolean @default(false)
  image         String?

  // Relations
  accounts       account[]
  sessions       session[]
  meetings       Meeting[]            @relation("MeetingHost")
  participations MeetingParticipant[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model account {
  id                    String    @id
  userId                String
  accountId             String
  providerId            String
  accessToken           String?   @db.Text
  refreshToken          String?   @db.Text
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  idToken               String?   @db.Text
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  user user @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model session {
  id        String   @id
  userId    String
  token     String   @unique
  expiresAt DateTime
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user user @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model verification {
  id         String   @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([identifier])
}

// ============================================
// Meeting Models
// ============================================

model Meeting {
  id          String  @id @default(cuid())
  roomName    String  @unique // Jitsi room identifier
  title       String
  description String?

  // Scheduling
  scheduledAt DateTime?
  startedAt   DateTime?
  endedAt     DateTime?
  duration    Int? // Duration in seconds

  // Status
  status MeetingStatus @default(SCHEDULED)

  // Host
  hostId String
  host   user   @relation("MeetingHost", fields: [hostId], references: [id])

  // Relations
  participants MeetingParticipant[]
  transcript   Transcript?
  summary      Summary?
  recordings   Recording[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([hostId])
  @@index([status])
  @@index([scheduledAt])
  @@index([roomName])
}

enum MeetingStatus {
  SCHEDULED
  ACTIVE
  ENDED
  CANCELLED
}

model MeetingParticipant {
  id String @id @default(cuid())

  meetingId String
  meeting   Meeting @relation(fields: [meetingId], references: [id], onDelete: Cascade)

  userId String? // Nullable for anonymous/guest participants
  user   user?   @relation(fields: [userId], references: [id])

  displayName String
  email       String?
  role        ParticipantRole @default(PARTICIPANT)

  joinedAt DateTime  @default(now())
  leftAt   DateTime?

  // Speaker identification for diarization
  speakerId Int? // Deepgram speaker ID mapping

  @@unique([meetingId, userId])
  @@index([meetingId])
  @@index([userId])
}

enum ParticipantRole {
  HOST
  CO_HOST
  PARTICIPANT
}

// ============================================
// Transcription Models
// ============================================

model Transcript {
  id String @id @default(cuid())

  meetingId String  @unique
  meeting   Meeting @relation(fields: [meetingId], references: [id], onDelete: Cascade)

  // Full transcript text (compiled from segments)
  fullText String? @db.Text

  // Structured segments with speaker info
  segments TranscriptSegment[]

  // Processing status
  status TranscriptStatus @default(PENDING)

  // Metadata
  language  String @default("en-US")
  wordCount Int?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum TranscriptStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

model TranscriptSegment {
  id String @id @default(cuid())

  transcriptId String
  transcript   Transcript @relation(fields: [transcriptId], references: [id], onDelete: Cascade)

  // Speaker info
  speakerId   Int // Diarization speaker ID (0, 1, 2, ...)
  speakerName String? // Resolved participant name

  // Timing (seconds from meeting start)
  startTime Float
  endTime   Float

  // Content
  text       String @db.Text
  confidence Float? // Transcription confidence score (0-1)

  // Word-level timing (optional, for precise highlighting)
  words Json? // Array of {word, start, end, confidence}

  createdAt DateTime @default(now())

  @@index([transcriptId])
  @@index([speakerId])
  @@index([startTime])
}

// ============================================
// AI Summary Models
// ============================================

model Summary {
  id String @id @default(cuid())

  meetingId String  @unique
  meeting   Meeting @relation(fields: [meetingId], references: [id], onDelete: Cascade)

  // Summary content
  title    String
  overview String @db.Text

  // Structured data (stored as JSON arrays)
  keyPoints   Json // Array of key discussion points
  actionItems Json // Array of {task, assignee?, dueDate?, completed}
  decisions   Json // Array of decisions made
  nextSteps   Json? // Array of follow-up items

  // Attendee summary
  attendees Json? // Array of {name, role, speakingTime?}

  // AI metadata
  model         String // e.g., "gpt-4o", "claude-3.5-sonnet"
  promptVersion String? // Version of prompt template used
  tokensUsed    Int?

  // Processing status
  status SummaryStatus @default(PENDING)
  error  String? // Error message if failed

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum SummaryStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

// ============================================
// Recording Models (Optional - for future use)
// ============================================

model Recording {
  id String @id @default(cuid())

  meetingId String
  meeting   Meeting @relation(fields: [meetingId], references: [id], onDelete: Cascade)

  // Storage info
  url      String
  filename String?
  format   String // e.g., "webm", "mp4", "mp3"
  size     Int? // File size in bytes
  duration Int? // Duration in seconds

  // Type of recording
  type RecordingType @default(VIDEO)

  // Processing status (for audio extraction)
  status RecordingStatus @default(PENDING)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([meetingId])
}

enum RecordingType {
  VIDEO
  AUDIO
  SCREEN
}

enum RecordingStatus {
  PENDING
  PROCESSING
  READY
  FAILED
}
